{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../../tsc-out/jsbi.mjs","../node_modules/@material-ui/icons/esm/Launch.js"],"names":["Parent","args","Class","isNativeReflectConstruct","Reflect","construct","a","push","apply","instance","Function","bind","setPrototypeOf","prototype","arguments","_cache","Map","undefined","fn","toString","call","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","this","constructor","Object","create","value","enumerable","writable","configurable","JSBI","length","sign","__kMaxLength","RangeError","BigInt","toDebugString","result","digit","join","radix","__toStringBasePowerOfTwo","__toStringGeneric","valueOf","Error","toNumber","__copy","i","__trim","newLength","last","pop","__initializeDigits","__decideRounding","__clzmsd","__clz30","__digit","__absoluteAdd","__inplaceMultiplyAdd","multiplier","summand","mLow","mHigh","carry","high","d","dLow","dHigh","pLow","__imul","pMid1","pMid2","__setDigit","__absoluteDivSmall","__inplaceAdd","startIndex","halfDigits","sum","__halfDigit","__setHalfDigit","__inplaceSub","subtrahend","borrow","current","r0","sub","r15","__inplaceRightShift","shift","__specialLeftShift","__unsignedDigit","__setDigitGrow","__halfDigitLength","len","digitIndex","previous","updated","__digitPow","arg","Math","floor","Number","isFinite","__zero","__isOneDigitInt","__oneDigit","__fromDouble","__fromString","SyntaxError","primitive","__toPrimitive","x","xLength","xMsd","msdLeadingZeros","xBitLength","Infinity","exponent","currentDigit","mantissaHigh","mantissaHighBitsUnset","mantissaLow","mantissaLowBitsUnset","rounding","signBit","__kBitConversionInts","__kBitConversionDouble","unaryMinus","bitwiseNot","__absoluteSubOne","__absoluteAddOne","exponentiate","y","expValue","__kMaxLengthBits","neededDigits","msd","runningSquare","multiply","resultLength","__multiplyAccumulate","divide","__absoluteCompare","quotient","resultSign","divisor","__absoluteDivLarge","remainder","remainderDigit","__absoluteModSmall","add","__absoluteSub","subtract","leftShift","__rightShiftByAbsolute","__leftShiftByAbsolute","signedRightShift","unsignedRightShift","lessThan","__compareToBigInt","lessThanOrEqual","greaterThan","greaterThanOrEqual","equal","notEqual","bitwiseAnd","max","__absoluteAnd","y1","__absoluteOr","__absoluteAndNot","bitwiseXor","__absoluteXor","bitwiseOr","asIntN","n","neededLength","topDigit","compareDigit","__truncateToNBits","__truncateAndSubFromPowerOfTwo","asUintN","bitsInTopDigit","ADD","__toNumeric","__isBigInt","LT","__compare","LE","GT","GE","EQ","__equalToNumber","NE","DataViewGetBigInt64","dataview","byteOffset","littleEndian","DataViewGetBigUint64","h","l","getUint32","low","DataViewSetBigInt64","DataViewSetBigUint64","d1","setUint32","mantissaBitsUnset","topUnconsumedBit","mask","digits","msdTopBit","remainingMantissaBits","__isWhitespace","c","string","cursor","charCodeAt","chars","bitsPerChar","__kMaxBitsPerChar","roundup","__kBitsPerCharTableMultiplier","bitsMin","__kBitsPerCharTableShift","limDigit","limAlpha","parts","partsBits","done","part","bits","__fillFromParts","charsSoFar","m","digitsSoFar","bitsInDigit","partBits","charMask","charsRequired","Array","pos","availableBits","newDigit","__kConversionChars","consumedBits","isRecursiveCall","secondHalf","bitLength","minBitsPerChar","secondHalfChars","conqueror","input","divisionResult","firstHalf","__unequalSign","leftNegative","__absoluteGreater","bothNegative","__absoluteLess","xSign","__compareToNumber","ySign","yAbs","abs","xDigit","__compareToDouble","rawExponent","yBitLength","compareMantissa","__comparisonResultToBool","op","r","inputLength","yLength","numPairs","tmp","tmpLength","diff","multiplicand","accumulator","accumulatorIndex","acc","m2Low","m2High","m1","m1Low","m1High","rLow","rMid1","rMid2","__internalMultiplyAdd","source","factor","rx","ry","upperHalf","lowerHalf","dividend","wantQuotient","wantRemainder","n2","q","qhatv","__clz15","qhat","u","vn1","halfDigitBuffer","j","ujn","rhat","vn2","ujn2","addDigit","__toShiftAmount","digitShift","bitsShift","grow","__rightShiftByMaximum","mustRoundDown","obj","hint","Symbol","toPrimitive","exoticToPrim","drop","min","limit","resultMsd","msdBitsConsumed","minuendMsd","base","__kBitConversionBuffer","ArrayBuffer","Float64Array","Int32Array","clz32","log","LN2","imul","b","createSvgIcon","React","createElement"],"mappings":"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","file":"static/js/6.3796af6a.chunk.js","sourcesContent":["import setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeFunction from \"./isNativeFunction\";\nimport construct from \"./construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","// Copyright 2018 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the “License”);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// <https://apache.org/licenses/LICENSE-2.0>.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an “AS IS” BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass JSBI extends Array {\n    constructor(length, sign) {\n        super(length);\n        this.sign = sign;\n        // Explicitly set the prototype as per\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, JSBI.prototype);\n        if (length > JSBI.__kMaxLength) {\n            throw new RangeError('Maximum BigInt size exceeded');\n        }\n    }\n    static BigInt(arg) {\n        if (typeof arg === 'number') {\n            if (arg === 0)\n                return JSBI.__zero();\n            if (JSBI.__isOneDigitInt(arg)) {\n                if (arg < 0) {\n                    return JSBI.__oneDigit(-arg, true);\n                }\n                return JSBI.__oneDigit(arg, false);\n            }\n            if (!Number.isFinite(arg) || Math.floor(arg) !== arg) {\n                throw new RangeError('The number ' + arg + ' cannot be converted to ' +\n                    'BigInt because it is not an integer');\n            }\n            return JSBI.__fromDouble(arg);\n        }\n        else if (typeof arg === 'string') {\n            const result = JSBI.__fromString(arg);\n            if (result === null) {\n                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');\n            }\n            return result;\n        }\n        else if (typeof arg === 'boolean') {\n            if (arg === true) {\n                return JSBI.__oneDigit(1, false);\n            }\n            return JSBI.__zero();\n        }\n        else if (typeof arg === 'object') {\n            if (arg.constructor === JSBI)\n                return arg;\n            const primitive = JSBI.__toPrimitive(arg);\n            return JSBI.BigInt(primitive);\n        }\n        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');\n    }\n    toDebugString() {\n        const result = ['BigInt['];\n        for (const digit of this) {\n            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');\n        }\n        result.push(']');\n        return result.join('');\n    }\n    toString(radix = 10) {\n        if (radix < 2 || radix > 36) {\n            throw new RangeError('toString() radix argument must be between 2 and 36');\n        }\n        if (this.length === 0)\n            return '0';\n        if ((radix & (radix - 1)) === 0) {\n            return JSBI.__toStringBasePowerOfTwo(this, radix);\n        }\n        return JSBI.__toStringGeneric(this, radix, false);\n    }\n    valueOf() {\n        throw new Error('Convert JSBI instances to native numbers using `toNumber`.');\n    }\n    // Equivalent of \"Number(my_bigint)\" in the native implementation.\n    // TODO: add more tests\n    static toNumber(x) {\n        const xLength = x.length;\n        if (xLength === 0)\n            return 0;\n        if (xLength === 1) {\n            const value = x.__unsignedDigit(0);\n            return x.sign ? -value : value;\n        }\n        const xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        if (xBitLength > 1024)\n            return x.sign ? -Infinity : Infinity;\n        let exponent = xBitLength - 1;\n        let currentDigit = xMsd;\n        let digitIndex = xLength - 1;\n        const shift = msdLeadingZeros + 3;\n        let mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;\n        mantissaHigh >>>= 12;\n        const mantissaHighBitsUnset = shift - 12;\n        let mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));\n        let mantissaLowBitsUnset = 20 + shift;\n        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            mantissaHigh |= (currentDigit >>> (30 - mantissaHighBitsUnset));\n            mantissaLow = currentDigit << mantissaHighBitsUnset + 2;\n            mantissaLowBitsUnset = mantissaHighBitsUnset + 2;\n        }\n        while (mantissaLowBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            if (mantissaLowBitsUnset >= 30) {\n                mantissaLow |= (currentDigit << (mantissaLowBitsUnset - 30));\n            }\n            else {\n                mantissaLow |= (currentDigit >>> (30 - mantissaLowBitsUnset));\n            }\n            mantissaLowBitsUnset -= 30;\n        }\n        const rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);\n        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {\n            mantissaLow = (mantissaLow + 1) >>> 0;\n            if (mantissaLow === 0) {\n                // Incrementing mantissaLow overflowed.\n                mantissaHigh++;\n                if ((mantissaHigh >>> 20) !== 0) {\n                    // Incrementing mantissaHigh overflowed.\n                    mantissaHigh = 0;\n                    exponent++;\n                    if (exponent > 1023) {\n                        // Incrementing the exponent overflowed.\n                        return x.sign ? -Infinity : Infinity;\n                    }\n                }\n            }\n        }\n        const signBit = x.sign ? (1 << 31) : 0;\n        exponent = (exponent + 0x3FF) << 20;\n        JSBI.__kBitConversionInts[1] = signBit | exponent | mantissaHigh;\n        JSBI.__kBitConversionInts[0] = mantissaLow;\n        return JSBI.__kBitConversionDouble[0];\n    }\n    // Operations.\n    static unaryMinus(x) {\n        if (x.length === 0)\n            return x;\n        const result = x.__copy();\n        result.sign = !x.sign;\n        return result;\n    }\n    static bitwiseNot(x) {\n        if (x.sign) {\n            // ~(-x) == ~(~(x-1)) == x-1\n            return JSBI.__absoluteSubOne(x).__trim();\n        }\n        // ~x == -x-1 == -(x+1)\n        return JSBI.__absoluteAddOne(x, true);\n    }\n    static exponentiate(x, y) {\n        if (y.sign) {\n            throw new RangeError('Exponent must be positive');\n        }\n        if (y.length === 0) {\n            return JSBI.__oneDigit(1, false);\n        }\n        if (x.length === 0)\n            return x;\n        if (x.length === 1 && x.__digit(0) === 1) {\n            // (-1) ** even_number == 1.\n            if (x.sign && (y.__digit(0) & 1) === 0) {\n                return JSBI.unaryMinus(x);\n            }\n            // (-1) ** odd_number == -1, 1 ** anything == 1.\n            return x;\n        }\n        // For all bases >= 2, very large exponents would lead to unrepresentable\n        // results.\n        if (y.length > 1)\n            throw new RangeError('BigInt too big');\n        let expValue = y.__unsignedDigit(0);\n        if (expValue === 1)\n            return x;\n        if (expValue >= JSBI.__kMaxLengthBits) {\n            throw new RangeError('BigInt too big');\n        }\n        if (x.length === 1 && x.__digit(0) === 2) {\n            // Fast path for 2^n.\n            const neededDigits = 1 + ((expValue / 30) | 0);\n            const sign = x.sign && ((expValue & 1) !== 0);\n            const result = new JSBI(neededDigits, sign);\n            result.__initializeDigits();\n            // All bits are zero. Now set the n-th bit.\n            const msd = 1 << (expValue % 30);\n            result.__setDigit(neededDigits - 1, msd);\n            return result;\n        }\n        let result = null;\n        let runningSquare = x;\n        // This implicitly sets the result's sign correctly.\n        if ((expValue & 1) !== 0)\n            result = x;\n        expValue >>= 1;\n        for (; expValue !== 0; expValue >>= 1) {\n            runningSquare = JSBI.multiply(runningSquare, runningSquare);\n            if ((expValue & 1) !== 0) {\n                if (result === null) {\n                    result = runningSquare;\n                }\n                else {\n                    result = JSBI.multiply(result, runningSquare);\n                }\n            }\n        }\n        // TODO see if there's a way for tsc to infer this will always happen?\n        return result;\n    }\n    static multiply(x, y) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return y;\n        let resultLength = x.length + y.length;\n        if (x.__clzmsd() + y.__clzmsd() >= 30) {\n            resultLength--;\n        }\n        const result = new JSBI(resultLength, x.sign !== y.sign);\n        result.__initializeDigits();\n        for (let i = 0; i < x.length; i++) {\n            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);\n        }\n        return result.__trim();\n    }\n    static divide(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return JSBI.__zero();\n        const resultSign = x.sign !== y.sign;\n        const divisor = y.__unsignedDigit(0);\n        let quotient;\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1) {\n                return resultSign === x.sign ? x : JSBI.unaryMinus(x);\n            }\n            quotient = JSBI.__absoluteDivSmall(x, divisor, null);\n        }\n        else {\n            quotient = JSBI.__absoluteDivLarge(x, y, true, false);\n        }\n        quotient.sign = resultSign;\n        return quotient.__trim();\n    }\n    static remainder(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return x;\n        const divisor = y.__unsignedDigit(0);\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1)\n                return JSBI.__zero();\n            const remainderDigit = JSBI.__absoluteModSmall(x, divisor);\n            if (remainderDigit === 0)\n                return JSBI.__zero();\n            return JSBI.__oneDigit(remainderDigit, x.sign);\n        }\n        const remainder = JSBI.__absoluteDivLarge(x, y, false, true);\n        remainder.sign = x.sign;\n        return remainder.__trim();\n    }\n    static add(x, y) {\n        const sign = x.sign;\n        if (sign === y.sign) {\n            // x + y == x + y\n            // -x + -y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x + -y == x - y == -(y - x)\n        // -x + y == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static subtract(x, y) {\n        const sign = x.sign;\n        if (sign !== y.sign) {\n            // x - (-y) == x + y\n            // (-x) - y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static leftShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__rightShiftByAbsolute(x, y);\n        return JSBI.__leftShiftByAbsolute(x, y);\n    }\n    static signedRightShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__leftShiftByAbsolute(x, y);\n        return JSBI.__rightShiftByAbsolute(x, y);\n    }\n    static unsignedRightShift() {\n        throw new TypeError('BigInts have no unsigned right shift; use >> instead');\n    }\n    static lessThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) < 0;\n    }\n    static lessThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) <= 0;\n    }\n    static greaterThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) > 0;\n    }\n    static greaterThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) >= 0;\n    }\n    static equal(x, y) {\n        if (x.sign !== y.sign)\n            return false;\n        if (x.length !== y.length)\n            return false;\n        for (let i = 0; i < x.length; i++) {\n            if (x.__digit(i) !== y.__digit(i))\n                return false;\n        }\n        return true;\n    }\n    static notEqual(x, y) {\n        return !JSBI.equal(x, y);\n    }\n    static bitwiseAnd(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteAnd(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            const resultLength = Math.max(x.length, y.length) + 1;\n            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n            // == -(((x-1) | (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteOr(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x & (-y) == x & ~(y-1) == x &~ (y-1)\n        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();\n    }\n    static bitwiseXor(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteXor(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n            const resultLength = Math.max(x.length, y.length);\n            const result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            return JSBI.__absoluteXor(result, y1, result).__trim();\n        }\n        const resultLength = Math.max(x.length, y.length) + 1;\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteXor(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static bitwiseOr(x, y) {\n        const resultLength = Math.max(x.length, y.length);\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteOr(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n            // == -(((x-1) & (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteAnd(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteAndNot(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static asIntN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} has less than {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const topDigit = x.__unsignedDigit(neededLength - 1);\n        const compareDigit = 1 << ((n - 1) % 30);\n        if (x.length === neededLength && topDigit < compareDigit)\n            return x;\n        // Otherwise truncate and simulate two's complement.\n        const hasBit = (topDigit & compareDigit) === compareDigit;\n        if (!hasBit)\n            return JSBI.__truncateToNBits(n, x);\n        if (!x.sign)\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);\n        if ((topDigit & (compareDigit - 1)) === 0) {\n            for (let i = neededLength - 2; i >= 0; i--) {\n                if (x.__digit(i) !== 0) {\n                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n                }\n            }\n            if (x.length === neededLength && topDigit === compareDigit)\n                return x;\n            return JSBI.__truncateToNBits(n, x);\n        }\n        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n    }\n    static asUintN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} is negative, simulate two's complement representation.\n        if (x.sign) {\n            if (n > JSBI.__kMaxLengthBits) {\n                throw new RangeError('BigInt too big');\n            }\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n        }\n        // If {x} is positive and has up to {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const bitsInTopDigit = n % 30;\n        if (x.length == neededLength) {\n            if (bitsInTopDigit === 0)\n                return x;\n            const topDigit = x.__digit(neededLength - 1);\n            if ((topDigit >>> bitsInTopDigit) === 0)\n                return x;\n        }\n        // Otherwise, truncate.\n        return JSBI.__truncateToNBits(n, x);\n    }\n    // Operators.\n    static ADD(x, y) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string') {\n            if (typeof y !== 'string')\n                y = y.toString();\n            return x + y;\n        }\n        if (typeof y === 'string') {\n            return x.toString() + y;\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {\n            return JSBI.add(x, y);\n        }\n        if (typeof x === 'number' && typeof y === 'number') {\n            return x + y;\n        }\n        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');\n    }\n    static LT(x, y) {\n        return JSBI.__compare(x, y, 0);\n    }\n    static LE(x, y) {\n        return JSBI.__compare(x, y, 1);\n    }\n    static GT(x, y) {\n        return JSBI.__compare(x, y, 2);\n    }\n    static GE(x, y) {\n        return JSBI.__compare(x, y, 3);\n    }\n    static EQ(x, y) {\n        while (true) {\n            if (JSBI.__isBigInt(x)) {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.equal(x, y);\n                return JSBI.EQ(y, x);\n            }\n            else if (typeof x === 'number') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'string') {\n                if (JSBI.__isBigInt(y)) {\n                    x = JSBI.__fromString(x);\n                    if (x === null)\n                        return false;\n                    return JSBI.equal(x, y);\n                }\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'boolean') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, +x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'symbol') {\n                if (JSBI.__isBigInt(y))\n                    return false;\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'object') {\n                if (typeof y === 'object' && y.constructor !== JSBI)\n                    return x == y;\n                x = JSBI.__toPrimitive(x);\n            }\n            else {\n                return x == y;\n            }\n        }\n    }\n    static NE(x, y) {\n        return !JSBI.EQ(x, y);\n    }\n    // DataView-related functionality.\n    static DataViewGetBigInt64(dataview, byteOffset, littleEndian = false) {\n        return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(dataview, byteOffset, littleEndian));\n    }\n    static DataViewGetBigUint64(dataview, byteOffset, littleEndian = false) {\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        const high = dataview.getUint32(byteOffset + h, littleEndian);\n        const low = dataview.getUint32(byteOffset + l, littleEndian);\n        const result = new JSBI(3, false);\n        result.__setDigit(0, low & 0x3FFFFFFF);\n        result.__setDigit(1, ((high & 0xFFFFFFF) << 2) | (low >>> 30));\n        result.__setDigit(2, high >>> 28);\n        return result.__trim();\n    }\n    static DataViewSetBigInt64(dataview, byteOffset, value, littleEndian = false) {\n        JSBI.DataViewSetBigUint64(dataview, byteOffset, value, littleEndian);\n    }\n    static DataViewSetBigUint64(dataview, byteOffset, value, littleEndian = false) {\n        value = JSBI.asUintN(64, value);\n        let high = 0;\n        let low = 0;\n        if (value.length > 0) {\n            low = value.__digit(0);\n            if (value.length > 1) {\n                const d1 = value.__digit(1);\n                low = low | d1 << 30;\n                high = d1 >>> 2;\n                if (value.length > 2) {\n                    high = high | (value.__digit(2) << 28);\n                }\n            }\n        }\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        dataview.setUint32(byteOffset + h, high, littleEndian);\n        dataview.setUint32(byteOffset + l, low, littleEndian);\n    }\n    // Helpers.\n    static __zero() {\n        return new JSBI(0, false);\n    }\n    static __oneDigit(value, sign) {\n        const result = new JSBI(1, sign);\n        result.__setDigit(0, value);\n        return result;\n    }\n    __copy() {\n        const result = new JSBI(this.length, this.sign);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i];\n        }\n        return result;\n    }\n    __trim() {\n        let newLength = this.length;\n        let last = this[newLength - 1];\n        while (last === 0) {\n            newLength--;\n            last = this[newLength - 1];\n            this.pop();\n        }\n        if (newLength === 0)\n            this.sign = false;\n        return this;\n    }\n    __initializeDigits() {\n        for (let i = 0; i < this.length; i++) {\n            this[i] = 0;\n        }\n    }\n    static __decideRounding(x, mantissaBitsUnset, digitIndex, currentDigit) {\n        if (mantissaBitsUnset > 0)\n            return -1;\n        let topUnconsumedBit;\n        if (mantissaBitsUnset < 0) {\n            topUnconsumedBit = -mantissaBitsUnset - 1;\n        }\n        else {\n            // {currentDigit} fit the mantissa exactly; look at the next digit.\n            if (digitIndex === 0)\n                return -1;\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            topUnconsumedBit = 29;\n        }\n        // If the most significant remaining bit is 0, round down.\n        let mask = 1 << topUnconsumedBit;\n        if ((currentDigit & mask) === 0)\n            return -1;\n        // If any other remaining bit is set, round up.\n        mask -= 1;\n        if ((currentDigit & mask) !== 0)\n            return 1;\n        while (digitIndex > 0) {\n            digitIndex--;\n            if (x.__digit(digitIndex) !== 0)\n                return 1;\n        }\n        return 0;\n    }\n    static __fromDouble(value) {\n        const sign = value < 0;\n        JSBI.__kBitConversionDouble[0] = value;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        const exponent = rawExponent - 0x3FF;\n        const digits = ((exponent / 30) | 0) + 1;\n        const result = new JSBI(digits, sign);\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        // 0-indexed position of most significant bit in most significant digit.\n        const msdTopBit = exponent % 30;\n        // Number of unused bits in the mantissa. We'll keep them shifted to the\n        // left (i.e. most significant part).\n        let remainingMantissaBits = 0;\n        // Next digit under construction.\n        let digit;\n        // First, build the MSD by shifting the mantissa appropriately.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            digit = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            digit = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        result.__setDigit(digits - 1, digit);\n        // Then fill in the rest of the digits.\n        for (let digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                digit = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                digit = 0;\n            }\n            result.__setDigit(digitIndex, digit);\n        }\n        return result.__trim();\n    }\n    static __isWhitespace(c) {\n        if (c <= 0x0D && c >= 0x09)\n            return true;\n        if (c <= 0x9F)\n            return c === 0x20;\n        if (c <= 0x01FFFF) {\n            return c === 0xA0 || c === 0x1680;\n        }\n        if (c <= 0x02FFFF) {\n            c &= 0x01FFFF;\n            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||\n                c === 0x5F || c === 0x1000;\n        }\n        return c === 0xFEFF;\n    }\n    static __fromString(string, radix = 0) {\n        let sign = 0;\n        let leadingZero = false;\n        const length = string.length;\n        let cursor = 0;\n        if (cursor === length)\n            return JSBI.__zero();\n        let current = string.charCodeAt(cursor);\n        // Skip whitespace.\n        while (JSBI.__isWhitespace(current)) {\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Detect radix.\n        if (current === 0x2B) { // '+'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = 1;\n        }\n        else if (current === 0x2D) { // '-'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = -1;\n        }\n        if (radix === 0) {\n            radix = 10;\n            if (current === 0x30) { // '0'\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    radix = 16;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'\n                    radix = 8;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'\n                    radix = 2;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        else if (radix === 16) {\n            if (current === 0x30) { // '0'\n                // Allow \"0x\" prefix.\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        if (sign !== 0 && radix !== 10)\n            return null;\n        // Skip leading zeros.\n        while (current === 0x30) {\n            leadingZero = true;\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Allocate result.\n        const chars = length - cursor;\n        let bitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        let roundup = JSBI.__kBitsPerCharTableMultiplier - 1;\n        if (chars > (1 << 30) / bitsPerChar)\n            return null;\n        const bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;\n        const resultLength = ((bitsMin + 29) / 30) | 0;\n        const result = new JSBI(resultLength, false);\n        // Parse.\n        const limDigit = radix < 10 ? radix : 10;\n        const limAlpha = radix > 10 ? radix - 10 : 0;\n        if ((radix & (radix - 1)) === 0) {\n            // Power-of-two radix.\n            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;\n            const parts = [];\n            const partsBits = [];\n            let done = false;\n            do {\n                let part = 0;\n                let bits = 0;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    bits += bitsPerChar;\n                    part = (part << bitsPerChar) | d;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                    if (bits + bitsPerChar > 30)\n                        break;\n                }\n                parts.push(part);\n                partsBits.push(bits);\n            } while (!done);\n            JSBI.__fillFromParts(result, parts, partsBits);\n        }\n        else {\n            result.__initializeDigits();\n            let done = false;\n            let charsSoFar = 0;\n            do {\n                let part = 0;\n                let multiplier = 1;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    const m = multiplier * radix;\n                    if (m > 0x3FFFFFFF)\n                        break;\n                    multiplier = m;\n                    part = part * radix + d;\n                    charsSoFar++;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                }\n                roundup = JSBI.__kBitsPerCharTableMultiplier * 30 - 1;\n                const digitsSoFar = (((bitsPerChar * charsSoFar + roundup) >>>\n                    JSBI.__kBitsPerCharTableShift) / 30) | 0;\n                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);\n            } while (!done);\n        }\n        if (cursor !== length) {\n            if (!JSBI.__isWhitespace(current))\n                return null;\n            for (cursor++; cursor < length; cursor++) {\n                current = string.charCodeAt(cursor);\n                if (!JSBI.__isWhitespace(current))\n                    return null;\n            }\n        }\n        // Get result.\n        result.sign = (sign === -1);\n        return result.__trim();\n    }\n    static __fillFromParts(result, parts, partsBits) {\n        let digitIndex = 0;\n        let digit = 0;\n        let bitsInDigit = 0;\n        for (let i = parts.length - 1; i >= 0; i--) {\n            const part = parts[i];\n            const partBits = partsBits[i];\n            digit |= (part << bitsInDigit);\n            bitsInDigit += partBits;\n            if (bitsInDigit === 30) {\n                result.__setDigit(digitIndex++, digit);\n                bitsInDigit = 0;\n                digit = 0;\n            }\n            else if (bitsInDigit > 30) {\n                result.__setDigit(digitIndex++, digit & 0x3FFFFFFF);\n                bitsInDigit -= 30;\n                digit = part >>> (partBits - bitsInDigit);\n            }\n        }\n        if (digit !== 0) {\n            if (digitIndex >= result.length)\n                throw new Error('implementation bug');\n            result.__setDigit(digitIndex++, digit);\n        }\n        for (; digitIndex < result.length; digitIndex++) {\n            result.__setDigit(digitIndex, 0);\n        }\n    }\n    static __toStringBasePowerOfTwo(x, radix) {\n        const length = x.length;\n        let bits = radix - 1;\n        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);\n        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);\n        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);\n        const bitsPerChar = bits;\n        const charMask = radix - 1;\n        const msd = x.__digit(length - 1);\n        const msdLeadingZeros = JSBI.__clz30(msd);\n        const bitLength = length * 30 - msdLeadingZeros;\n        let charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;\n        if (x.sign)\n            charsRequired++;\n        if (charsRequired > (1 << 28))\n            throw new Error('string too long');\n        const result = new Array(charsRequired);\n        let pos = charsRequired - 1;\n        let digit = 0;\n        let availableBits = 0;\n        for (let i = 0; i < length - 1; i++) {\n            const newDigit = x.__digit(i);\n            const current = (digit | (newDigit << availableBits)) & charMask;\n            result[pos--] = JSBI.__kConversionChars[current];\n            const consumedBits = bitsPerChar - availableBits;\n            digit = newDigit >>> consumedBits;\n            availableBits = 30 - consumedBits;\n            while (availableBits >= bitsPerChar) {\n                result[pos--] = JSBI.__kConversionChars[digit & charMask];\n                digit >>>= bitsPerChar;\n                availableBits -= bitsPerChar;\n            }\n        }\n        const current = (digit | (msd << availableBits)) & charMask;\n        result[pos--] = JSBI.__kConversionChars[current];\n        digit = msd >>> (bitsPerChar - availableBits);\n        while (digit !== 0) {\n            result[pos--] = JSBI.__kConversionChars[digit & charMask];\n            digit >>>= bitsPerChar;\n        }\n        if (x.sign)\n            result[pos--] = '-';\n        if (pos !== -1)\n            throw new Error('implementation bug');\n        return result.join('');\n    }\n    static __toStringGeneric(x, radix, isRecursiveCall) {\n        const length = x.length;\n        if (length === 0)\n            return '';\n        if (length === 1) {\n            let result = x.__unsignedDigit(0).toString(radix);\n            if (isRecursiveCall === false && x.sign) {\n                result = '-' + result;\n            }\n            return result;\n        }\n        const bitLength = length * 30 - JSBI.__clz30(x.__digit(length - 1));\n        const maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        const minBitsPerChar = maxBitsPerChar - 1;\n        let charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;\n        charsRequired += minBitsPerChar - 1;\n        charsRequired = (charsRequired / minBitsPerChar) | 0;\n        const secondHalfChars = (charsRequired + 1) >> 1;\n        // Divide-and-conquer: split by a power of {radix} that's approximately\n        // the square root of {x}, then recurse.\n        const conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));\n        let quotient;\n        let secondHalf;\n        const divisor = conqueror.__unsignedDigit(0);\n        if (conqueror.length === 1 && divisor <= 0x7FFF) {\n            quotient = new JSBI(x.length, false);\n            quotient.__initializeDigits();\n            let remainder = 0;\n            for (let i = x.length * 2 - 1; i >= 0; i--) {\n                const input = (remainder << 15) | x.__halfDigit(i);\n                quotient.__setHalfDigit(i, (input / divisor) | 0);\n                remainder = (input % divisor) | 0;\n            }\n            secondHalf = remainder.toString(radix);\n        }\n        else {\n            const divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);\n            quotient = divisionResult.quotient;\n            const remainder = divisionResult.remainder.__trim();\n            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);\n        }\n        quotient.__trim();\n        let firstHalf = JSBI.__toStringGeneric(quotient, radix, true);\n        while (secondHalf.length < secondHalfChars) {\n            secondHalf = '0' + secondHalf;\n        }\n        if (isRecursiveCall === false && x.sign) {\n            firstHalf = '-' + firstHalf;\n        }\n        return firstHalf + secondHalf;\n    }\n    static __unequalSign(leftNegative) {\n        return leftNegative ? -1 : 1;\n    }\n    static __absoluteGreater(bothNegative) {\n        return bothNegative ? -1 : 1;\n    }\n    static __absoluteLess(bothNegative) {\n        return bothNegative ? 1 : -1;\n    }\n    static __compareToBigInt(x, y) {\n        const xSign = x.sign;\n        if (xSign !== y.sign)\n            return JSBI.__unequalSign(xSign);\n        const result = JSBI.__absoluteCompare(x, y);\n        if (result > 0)\n            return JSBI.__absoluteGreater(xSign);\n        if (result < 0)\n            return JSBI.__absoluteLess(xSign);\n        return 0;\n    }\n    static __compareToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            const xSign = x.sign;\n            const ySign = (y < 0);\n            if (xSign !== ySign)\n                return JSBI.__unequalSign(xSign);\n            if (x.length === 0) {\n                if (ySign)\n                    throw new Error('implementation bug');\n                return y === 0 ? 0 : -1;\n            }\n            // Any multi-digit BigInt is bigger than an int32.\n            if (x.length > 1)\n                return JSBI.__absoluteGreater(xSign);\n            const yAbs = Math.abs(y);\n            const xDigit = x.__unsignedDigit(0);\n            if (xDigit > yAbs)\n                return JSBI.__absoluteGreater(xSign);\n            if (xDigit < yAbs)\n                return JSBI.__absoluteLess(xSign);\n            return 0;\n        }\n        return JSBI.__compareToDouble(x, y);\n    }\n    static __compareToDouble(x, y) {\n        if (y !== y)\n            return y; // NaN.\n        if (y === Infinity)\n            return -1;\n        if (y === -Infinity)\n            return 1;\n        const xSign = x.sign;\n        const ySign = (y < 0);\n        if (xSign !== ySign)\n            return JSBI.__unequalSign(xSign);\n        if (y === 0) {\n            throw new Error('implementation bug: should be handled elsewhere');\n        }\n        if (x.length === 0)\n            return -1;\n        JSBI.__kBitConversionDouble[0] = y;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        if (rawExponent === 0x7FF) {\n            throw new Error('implementation bug: handled elsewhere');\n        }\n        const exponent = rawExponent - 0x3FF;\n        if (exponent < 0) {\n            // The absolute value of y is less than 1. Only 0n has an absolute\n            // value smaller than that, but we've already covered that case.\n            return JSBI.__absoluteGreater(xSign);\n        }\n        const xLength = x.length;\n        let xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        const yBitLength = exponent + 1;\n        if (xBitLength < yBitLength)\n            return JSBI.__absoluteLess(xSign);\n        if (xBitLength > yBitLength)\n            return JSBI.__absoluteGreater(xSign);\n        // Same sign, same bit length. Shift mantissa to align with x and compare\n        // bit for bit.\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        const msdTopBit = 29 - msdLeadingZeros;\n        if (msdTopBit !== (((xBitLength - 1) % 30) | 0)) {\n            throw new Error('implementation bug');\n        }\n        let compareMantissa; // Shifted chunk of mantissa.\n        let remainingMantissaBits = 0;\n        // First, compare most significant digit against beginning of mantissa.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            compareMantissa = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            compareMantissa = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            compareMantissa =\n                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        xMsd = xMsd >>> 0;\n        compareMantissa = compareMantissa >>> 0;\n        if (xMsd > compareMantissa)\n            return JSBI.__absoluteGreater(xSign);\n        if (xMsd < compareMantissa)\n            return JSBI.__absoluteLess(xSign);\n        // Then, compare additional digits against remaining mantissa bits.\n        for (let digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                compareMantissa = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                compareMantissa = 0;\n            }\n            const digit = x.__unsignedDigit(digitIndex);\n            if (digit > compareMantissa)\n                return JSBI.__absoluteGreater(xSign);\n            if (digit < compareMantissa)\n                return JSBI.__absoluteLess(xSign);\n        }\n        // Integer parts are equal; check whether {y} has a fractional part.\n        if (mantissaHigh !== 0 || mantissaLow !== 0) {\n            if (remainingMantissaBits === 0)\n                throw new Error('implementation bug');\n            return JSBI.__absoluteLess(xSign);\n        }\n        return 0;\n    }\n    static __equalToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            if (y === 0)\n                return x.length === 0;\n            // Any multi-digit BigInt is bigger than an int32.\n            return (x.length === 1) && (x.sign === (y < 0)) &&\n                (x.__unsignedDigit(0) === Math.abs(y));\n        }\n        return JSBI.__compareToDouble(x, y) === 0;\n    }\n    // Comparison operations, chosen such that \"op ^ 2\" reverses direction:\n    // 0 - lessThan\n    // 1 - lessThanOrEqual\n    // 2 - greaterThan\n    // 3 - greaterThanOrEqual\n    static __comparisonResultToBool(result, op) {\n        switch (op) {\n            case 0: return result < 0;\n            case 1: return result <= 0;\n            case 2: return result > 0;\n            case 3: return result >= 0;\n        }\n    }\n    static __compare(x, y, op) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string' && typeof y === 'string') {\n            switch (op) {\n                case 0: return x < y;\n                case 1: return x <= y;\n                case 2: return x > y;\n                case 3: return x >= y;\n            }\n        }\n        if (JSBI.__isBigInt(x) && typeof y === 'string') {\n            y = JSBI.__fromString(y);\n            if (y === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        if (typeof x === 'string' && JSBI.__isBigInt(y)) {\n            x = JSBI.__fromString(x);\n            if (x === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x)) {\n            if (JSBI.__isBigInt(y)) {\n                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n            }\n            if (typeof y !== 'number')\n                throw new Error('implementation bug');\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);\n        }\n        if (typeof x !== 'number')\n            throw new Error('implementation bug');\n        if (JSBI.__isBigInt(y)) {\n            // Note that \"op ^ 2\" reverses the op's direction.\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));\n        }\n        if (typeof y !== 'number')\n            throw new Error('implementation bug');\n        switch (op) {\n            case 0: return x < y;\n            case 1: return x <= y;\n            case 2: return x > y;\n            case 3: return x >= y;\n        }\n    }\n    __clzmsd() {\n        return JSBI.__clz30(this.__digit(this.length - 1));\n    }\n    static __absoluteAdd(x, y, resultSign) {\n        if (x.length < y.length)\n            return JSBI.__absoluteAdd(y, x, resultSign);\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        let resultLength = x.length;\n        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {\n            resultLength++;\n        }\n        const result = new JSBI(resultLength, resultSign);\n        let carry = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) + y.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (i < result.length) {\n            result.__setDigit(i, carry);\n        }\n        return result.__trim();\n    }\n    static __absoluteSub(x, y, resultSign) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        const result = new JSBI(x.length, resultSign);\n        let borrow = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) - y.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        return result.__trim();\n    }\n    static __absoluteAddOne(x, sign, result = null) {\n        const inputLength = x.length;\n        if (result === null) {\n            result = new JSBI(inputLength, sign);\n        }\n        else {\n            result.sign = sign;\n        }\n        let carry = 1;\n        for (let i = 0; i < inputLength; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (carry !== 0) {\n            result.__setDigitGrow(inputLength, 1);\n        }\n        return result;\n    }\n    static __absoluteSubOne(x, resultLength) {\n        const length = x.length;\n        resultLength = resultLength || length;\n        const result = new JSBI(resultLength, false);\n        let borrow = 1;\n        for (let i = 0; i < length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (borrow !== 0)\n            throw new Error('implementation bug');\n        for (let i = length; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAnd(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = numPairs;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & y.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAndNot(x, y, result = null) {\n        const xLength = x.length;\n        const yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteOr(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) | y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteXor(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteCompare(x, y) {\n        const diff = x.length - y.length;\n        if (diff !== 0)\n            return diff;\n        let i = x.length - 1;\n        while (i >= 0 && x.__digit(i) === y.__digit(i))\n            i--;\n        if (i < 0)\n            return 0;\n        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;\n    }\n    static __multiplyAccumulate(multiplicand, multiplier, accumulator, accumulatorIndex) {\n        if (multiplier === 0)\n            return;\n        const m2Low = multiplier & 0x7FFF;\n        const m2High = multiplier >>> 15;\n        let carry = 0;\n        let high = 0;\n        for (let i = 0; i < multiplicand.length; i++, accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            const m1 = multiplicand.__digit(i);\n            const m1Low = m1 & 0x7FFF;\n            const m1High = m1 >>> 15;\n            const rLow = JSBI.__imul(m1Low, m2Low);\n            const rMid1 = JSBI.__imul(m1Low, m2High);\n            const rMid2 = JSBI.__imul(m1High, m2Low);\n            const rHigh = JSBI.__imul(m1High, m2High);\n            acc += high + rLow + carry;\n            carry = acc >>> 30;\n            acc &= 0x3FFFFFFF;\n            acc += ((rMid1 & 0x7FFF) << 15) + ((rMid2 & 0x7FFF) << 15);\n            carry += acc >>> 30;\n            high = rHigh + (rMid1 >>> 15) + (rMid2 >>> 15);\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n        for (; carry !== 0 || high !== 0; accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            acc += carry + high;\n            high = 0;\n            carry = acc >>> 30;\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n    }\n    static __internalMultiplyAdd(source, factor, summand, n, result) {\n        let carry = summand;\n        let high = 0;\n        for (let i = 0; i < n; i++) {\n            const digit = source.__digit(i);\n            const rx = JSBI.__imul(digit & 0x7FFF, factor);\n            const ry = JSBI.__imul(digit >>> 15, factor);\n            const r = rx + ((ry & 0x7FFF) << 15) + high + carry;\n            carry = r >>> 30;\n            high = ry >>> 15;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (result.length > n) {\n            result.__setDigit(n++, carry + high);\n            while (n < result.length) {\n                result.__setDigit(n++, 0);\n            }\n        }\n        else {\n            if (carry + high !== 0)\n                throw new Error('implementation bug');\n        }\n    }\n    __inplaceMultiplyAdd(multiplier, summand, length) {\n        if (length > this.length)\n            length = this.length;\n        const mLow = multiplier & 0x7FFF;\n        const mHigh = multiplier >>> 15;\n        let carry = 0;\n        let high = summand;\n        for (let i = 0; i < length; i++) {\n            const d = this.__digit(i);\n            const dLow = d & 0x7FFF;\n            const dHigh = d >>> 15;\n            const pLow = JSBI.__imul(dLow, mLow);\n            const pMid1 = JSBI.__imul(dLow, mHigh);\n            const pMid2 = JSBI.__imul(dHigh, mLow);\n            const pHigh = JSBI.__imul(dHigh, mHigh);\n            let result = high + pLow + carry;\n            carry = result >>> 30;\n            result &= 0x3FFFFFFF;\n            result += ((pMid1 & 0x7FFF) << 15) + ((pMid2 & 0x7FFF) << 15);\n            carry += result >>> 30;\n            high = pHigh + (pMid1 >>> 15) + (pMid2 >>> 15);\n            this.__setDigit(i, result & 0x3FFFFFFF);\n        }\n        if (carry !== 0 || high !== 0) {\n            throw new Error('implementation bug');\n        }\n    }\n    static __absoluteDivSmall(x, divisor, quotient = null) {\n        if (quotient === null)\n            quotient = new JSBI(x.length, false);\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i -= 2) {\n            let input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            const upperHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            input = ((remainder << 15) | x.__halfDigit(i - 1)) >>> 0;\n            const lowerHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            quotient.__setDigit(i >>> 1, (upperHalf << 15) | lowerHalf);\n        }\n        return quotient;\n    }\n    static __absoluteModSmall(x, divisor) {\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i--) {\n            const input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            remainder = (input % divisor) | 0;\n        }\n        return remainder;\n    }\n    static __absoluteDivLarge(dividend, divisor, wantQuotient, wantRemainder) {\n        const n = divisor.__halfDigitLength();\n        const n2 = divisor.length;\n        const m = dividend.__halfDigitLength() - n;\n        let q = null;\n        if (wantQuotient) {\n            q = new JSBI((m + 2) >>> 1, false);\n            q.__initializeDigits();\n        }\n        const qhatv = new JSBI((n + 2) >>> 1, false);\n        qhatv.__initializeDigits();\n        // D1.\n        const shift = JSBI.__clz15(divisor.__halfDigit(n - 1));\n        if (shift > 0) {\n            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);\n        }\n        const u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);\n        // D2.\n        const vn1 = divisor.__halfDigit(n - 1);\n        let halfDigitBuffer = 0;\n        for (let j = m; j >= 0; j--) {\n            // D3.\n            let qhat = 0x7FFF;\n            const ujn = u.__halfDigit(j + n);\n            if (ujn !== vn1) {\n                const input = ((ujn << 15) | u.__halfDigit(j + n - 1)) >>> 0;\n                qhat = (input / vn1) | 0;\n                let rhat = (input % vn1) | 0;\n                const vn2 = divisor.__halfDigit(n - 2);\n                const ujn2 = u.__halfDigit(j + n - 2);\n                while ((JSBI.__imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {\n                    qhat--;\n                    rhat += vn1;\n                    if (rhat > 0x7FFF)\n                        break;\n                }\n            }\n            // D4.\n            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);\n            let c = u.__inplaceSub(qhatv, j, n + 1);\n            if (c !== 0) {\n                c = u.__inplaceAdd(divisor, j, n);\n                u.__setHalfDigit(j + n, (u.__halfDigit(j + n) + c) & 0x7FFF);\n                qhat--;\n            }\n            if (wantQuotient) {\n                if (j & 1) {\n                    halfDigitBuffer = qhat << 15;\n                }\n                else {\n                    // TODO make this statically determinable\n                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);\n                }\n            }\n        }\n        if (wantRemainder) {\n            u.__inplaceRightShift(shift);\n            if (wantQuotient) {\n                return { quotient: q, remainder: u };\n            }\n            return u;\n        }\n        if (wantQuotient)\n            return q;\n        // TODO find a way to make this statically unreachable?\n        throw new Error('unreachable');\n    }\n    static __clz15(value) {\n        return JSBI.__clz30(value) - 15;\n    }\n    // TODO: work on full digits, like __inplaceSub?\n    __inplaceAdd(summand, startIndex, halfDigits) {\n        let carry = 0;\n        for (let i = 0; i < halfDigits; i++) {\n            const sum = this.__halfDigit(startIndex + i) +\n                summand.__halfDigit(i) +\n                carry;\n            carry = sum >>> 15;\n            this.__setHalfDigit(startIndex + i, sum & 0x7FFF);\n        }\n        return carry;\n    }\n    __inplaceSub(subtrahend, startIndex, halfDigits) {\n        const fullSteps = (halfDigits - 1) >>> 1;\n        let borrow = 0;\n        if (startIndex & 1) {\n            // this:   [..][..][..]\n            // subtr.:   [..][..]\n            startIndex >>= 1;\n            let current = this.__digit(startIndex);\n            let r0 = current & 0x7FFF;\n            let i = 0;\n            for (; i < fullSteps; i++) {\n                const sub = subtrahend.__digit(i);\n                const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - (sub >>> 15) - borrow;\n                borrow = (r0 >>> 15) & 1;\n            }\n            // Unrolling the last iteration gives a 5% performance benefit!\n            const sub = subtrahend.__digit(i);\n            const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n            borrow = (r15 >>> 15) & 1;\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            const subTop = sub >>> 15;\n            if (startIndex + i + 1 >= this.length) {\n                throw new RangeError('out of bounds');\n            }\n            if ((halfDigits & 1) === 0) {\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - subTop - borrow;\n                borrow = (r0 >>> 15) & 1;\n                this.__setDigit(startIndex + subtrahend.length, (current & 0x3FFF8000) | (r0 & 0x7FFF));\n            }\n        }\n        else {\n            startIndex >>= 1;\n            let i = 0;\n            for (; i < subtrahend.length - 1; i++) {\n                const current = this.__digit(startIndex + i);\n                const sub = subtrahend.__digit(i);\n                const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n                borrow = (r0 >>> 15) & 1;\n                const r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            }\n            const current = this.__digit(startIndex + i);\n            const sub = subtrahend.__digit(i);\n            const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n            borrow = (r0 >>> 15) & 1;\n            let r15 = 0;\n            if ((halfDigits & 1) === 0) {\n                r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n            }\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n        }\n        return borrow;\n    }\n    __inplaceRightShift(shift) {\n        if (shift === 0)\n            return;\n        let carry = this.__digit(0) >>> shift;\n        const last = this.length - 1;\n        for (let i = 0; i < last; i++) {\n            const d = this.__digit(i + 1);\n            this.__setDigit(i, ((d << (30 - shift)) & 0x3FFFFFFF) | carry);\n            carry = d >>> shift;\n        }\n        this.__setDigit(last, carry);\n    }\n    static __specialLeftShift(x, shift, addDigit) {\n        const n = x.length;\n        const resultLength = n + addDigit;\n        const result = new JSBI(resultLength, false);\n        if (shift === 0) {\n            for (let i = 0; i < n; i++)\n                result.__setDigit(i, x.__digit(i));\n            if (addDigit > 0)\n                result.__setDigit(n, 0);\n            return result;\n        }\n        let carry = 0;\n        for (let i = 0; i < n; i++) {\n            const d = x.__digit(i);\n            result.__setDigit(i, ((d << shift) & 0x3FFFFFFF) | carry);\n            carry = d >>> (30 - shift);\n        }\n        if (addDigit > 0) {\n            result.__setDigit(n, carry);\n        }\n        return result;\n    }\n    static __leftShiftByAbsolute(x, y) {\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            throw new RangeError('BigInt too big');\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        const length = x.length;\n        const grow = bitsShift !== 0 &&\n            (x.__digit(length - 1) >>> (30 - bitsShift)) !== 0;\n        const resultLength = length + digitShift + (grow ? 1 : 0);\n        const result = new JSBI(resultLength, x.sign);\n        if (bitsShift === 0) {\n            let i = 0;\n            for (; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (; i < resultLength; i++) {\n                result.__setDigit(i, x.__digit(i - digitShift));\n            }\n        }\n        else {\n            let carry = 0;\n            for (let i = 0; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (let i = 0; i < length; i++) {\n                const d = x.__digit(i);\n                result.__setDigit(i + digitShift, ((d << bitsShift) & 0x3FFFFFFF) | carry);\n                carry = d >>> (30 - bitsShift);\n            }\n            if (grow) {\n                result.__setDigit(length + digitShift, carry);\n            }\n            else {\n                if (carry !== 0)\n                    throw new Error('implementation bug');\n            }\n        }\n        return result.__trim();\n    }\n    static __rightShiftByAbsolute(x, y) {\n        const length = x.length;\n        const sign = x.sign;\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        let resultLength = length - digitShift;\n        if (resultLength <= 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        // For negative numbers, round down if any bit was shifted out (so that\n        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n        // and whether itc an cause overflow into a new digit. If we allocate the\n        // result large enough up front, it avoids having to do grow it later.\n        let mustRoundDown = false;\n        if (sign) {\n            const mask = (1 << bitsShift) - 1;\n            if ((x.__digit(digitShift) & mask) !== 0) {\n                mustRoundDown = true;\n            }\n            else {\n                for (let i = 0; i < digitShift; i++) {\n                    if (x.__digit(i) !== 0) {\n                        mustRoundDown = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // If bitsShift is non-zero, it frees up bits, preventing overflow.\n        if (mustRoundDown && bitsShift === 0) {\n            // Overflow cannot happen if the most significant digit has unset bits.\n            const msd = x.__digit(length - 1);\n            const roundingCanOverflow = ~msd === 0;\n            if (roundingCanOverflow)\n                resultLength++;\n        }\n        let result = new JSBI(resultLength, sign);\n        if (bitsShift === 0) {\n            // Zero out any overflow digit (see \"roundingCanOverflow\" above).\n            result.__setDigit(resultLength - 1, 0);\n            for (let i = digitShift; i < length; i++) {\n                result.__setDigit(i - digitShift, x.__digit(i));\n            }\n        }\n        else {\n            let carry = x.__digit(digitShift) >>> bitsShift;\n            const last = length - digitShift - 1;\n            for (let i = 0; i < last; i++) {\n                const d = x.__digit(i + digitShift + 1);\n                result.__setDigit(i, ((d << (30 - bitsShift)) & 0x3FFFFFFF) | carry);\n                carry = d >>> bitsShift;\n            }\n            result.__setDigit(last, carry);\n        }\n        if (mustRoundDown) {\n            // Since the result is negative, rounding down means adding one to its\n            // absolute value. This cannot overflow.\n            result = JSBI.__absoluteAddOne(result, true, result);\n        }\n        return result.__trim();\n    }\n    static __rightShiftByMaximum(sign) {\n        if (sign) {\n            return JSBI.__oneDigit(1, true);\n        }\n        return JSBI.__zero();\n    }\n    static __toShiftAmount(x) {\n        if (x.length > 1)\n            return -1;\n        const value = x.__unsignedDigit(0);\n        if (value > JSBI.__kMaxLengthBits)\n            return -1;\n        return value;\n    }\n    static __toPrimitive(obj, hint = 'default') {\n        if (typeof obj !== 'object')\n            return obj;\n        if (obj.constructor === JSBI)\n            return obj;\n        if (typeof Symbol !== 'undefined' &&\n            typeof Symbol.toPrimitive === 'symbol') {\n            const exoticToPrim = obj[Symbol.toPrimitive];\n            if (exoticToPrim) {\n                const primitive = exoticToPrim(hint);\n                if (typeof primitive !== 'object')\n                    return primitive;\n                throw new TypeError('Cannot convert object to primitive value');\n            }\n        }\n        const valueOf = obj.valueOf;\n        if (valueOf) {\n            const primitive = valueOf.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        const toString = obj.toString;\n        if (toString) {\n            const primitive = toString.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        throw new TypeError('Cannot convert object to primitive value');\n    }\n    static __toNumeric(value) {\n        if (JSBI.__isBigInt(value))\n            return value;\n        return +value;\n    }\n    static __isBigInt(value) {\n        return typeof value === 'object' && value !== null &&\n            value.constructor === JSBI;\n    }\n    static __truncateToNBits(n, x) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, x.sign);\n        const last = neededDigits - 1;\n        for (let i = 0; i < last; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        let msd = x.__digit(last);\n        if ((n % 30) !== 0) {\n            const drop = 32 - (n % 30);\n            msd = (msd << drop) >>> drop;\n        }\n        result.__setDigit(last, msd);\n        return result.__trim();\n    }\n    static __truncateAndSubFromPowerOfTwo(n, x, resultSign) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, resultSign);\n        let i = 0;\n        const last = neededDigits - 1;\n        let borrow = 0;\n        const limit = Math.min(last, x.length);\n        for (; i < limit; i++) {\n            const r = 0 - x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < last; i++) {\n            result.__setDigit(i, (-borrow & 0x3FFFFFFF) | 0);\n        }\n        let msd = last < x.length ? x.__digit(last) : 0;\n        const msdBitsConsumed = n % 30;\n        let resultMsd;\n        if (msdBitsConsumed === 0) {\n            resultMsd = 0 - msd - borrow;\n            resultMsd &= 0x3FFFFFFF;\n        }\n        else {\n            const drop = 32 - msdBitsConsumed;\n            msd = (msd << drop) >>> drop;\n            const minuendMsd = 1 << (32 - drop);\n            resultMsd = minuendMsd - msd - borrow;\n            resultMsd &= (minuendMsd - 1);\n        }\n        result.__setDigit(last, resultMsd);\n        return result.__trim();\n    }\n    // Digit helpers.\n    __digit(i) {\n        return this[i];\n    }\n    __unsignedDigit(i) {\n        return this[i] >>> 0;\n    }\n    __setDigit(i, digit) {\n        this[i] = digit | 0;\n    }\n    __setDigitGrow(i, digit) {\n        this[i] = digit | 0;\n    }\n    __halfDigitLength() {\n        const len = this.length;\n        if (this.__unsignedDigit(len - 1) <= 0x7FFF)\n            return len * 2 - 1;\n        return len * 2;\n    }\n    __halfDigit(i) {\n        return (this[i >>> 1] >>> ((i & 1) * 15)) & 0x7FFF;\n    }\n    __setHalfDigit(i, value) {\n        const digitIndex = i >>> 1;\n        const previous = this.__digit(digitIndex);\n        const updated = (i & 1) ? (previous & 0x7FFF) | (value << 15)\n            : (previous & 0x3FFF8000) | (value & 0x7FFF);\n        this.__setDigit(digitIndex, updated);\n    }\n    static __digitPow(base, exponent) {\n        let result = 1;\n        while (exponent > 0) {\n            if (exponent & 1)\n                result *= base;\n            exponent >>>= 1;\n            base *= base;\n        }\n        return result;\n    }\n    static __isOneDigitInt(x) {\n        return (x & 0x3FFFFFFF) === x;\n    }\n}\nJSBI.__kMaxLength = 1 << 25;\nJSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;\n// Lookup table for the maximum number of bits required per character of a\n// base-N string representation of a number. To increase accuracy, the array\n// value is the actual value multiplied by 32. To generate this table:\n//\n// for (let i = 0; i <= 36; i++) {\n//   console.log(Math.ceil(Math.log2(i) * 32) + ',');\n// }\nJSBI.__kMaxBitsPerChar = [\n    0, 0, 32, 51, 64, 75, 83, 90, 96,\n    102, 107, 111, 115, 119, 122, 126, 128,\n    131, 134, 136, 139, 141, 143, 145, 147,\n    149, 151, 153, 154, 156, 158, 159, 160,\n    162, 163, 165, 166, // 33..36\n];\nJSBI.__kBitsPerCharTableShift = 5;\nJSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;\nJSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');\nJSBI.__kBitConversionBuffer = new ArrayBuffer(8);\nJSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);\nJSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\n// For IE11 compatibility.\n// Note that the custom replacements are tailored for JSBI's needs, and as\n// such are not reusable as general-purpose polyfills.\nJSBI.__clz30 = Math.clz32 ? function (x) {\n    return Math.clz32(x) - 2;\n} : function (x) {\n    if (x === 0)\n        return 30;\n    return 29 - (Math.log(x >>> 0) / Math.LN2 | 0) | 0;\n};\nJSBI.__imul = Math.imul || function (a, b) {\n    return (a * b) | 0;\n};\nexport default JSBI;\n//# sourceMappingURL=jsbi.js.map","import React from 'react';\nimport createSvgIcon from './utils/createSvgIcon';\nexport default createSvgIcon(React.createElement(\"path\", {\n  d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z\"\n}), 'Launch');"],"sourceRoot":""}